{\rtf1\ansi\ansicpg1252\cocoartf1344\cocoasubrtf720
{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;\red244\green244\blue244;}
\margl1440\margr1440\vieww27960\viewh13780\viewkind0
\deftab720
\pard\pardeftab720\sl264

\f0\fs24 \cf0 \cb2 \expnd0\expndtw0\kerning0
RenderObject\
	-Wrap ObjectIdentifier and Mesh/Camera/Texture/Whatever\
	-Created only by the Renderer Interface(as a factory) with a pointer to said Renderer (to add itself to updated later and such)\

\f1\b \

\f0\b0 Camera Class / ObjectIdentifier code\
	-Simple stuff
\f1\b \

\f0\b0 \
Automatic material uniform passing to shader when it is used
\f1\b \
	
\f0\b0 -maybe a Material::Enable() similar to how shader works\
	-Includes all texture uniforms, gloss / roughness / metallic values, etc
\f1\b \
\

\f0\b0 (next two items are the same priority)\
Shader Module System
\f1\b \
	
\f0\b0 -decouple lighting and shader code that calculates lighting vars from material
\f1\b \
     
\f0\b0 -This allows the user to override the material calculations for custom effects without being able to mess with lighting\
	-They will still have flags in the renderer interface to control basic lighting, such as \'93NOT_LIT\'94, \'93DEFAULT\'94, etc\
	-Our original discussion had each material var calculation in a \'93module\'94 sort of thing, might be too overcomplicated, might be worth it
\f1\b \
\

\f0\b0 Instancing\
	-You know this one :D\

\f1\b \
Renderer interface (The stuff that won\'92t get overridden from abstraction)\
     -Automatic default uniform passing, such as matrices\
	-Extensive configuration struct with vars for each feature we plan to support 
\f0\b0 \
	-Make it easy to data-drive configuration struct in an engine or wrapper later on for users
\f1\b \
	-Will contain LightingImplementation (set this to your class that implements lighting implementation)\
	-Will contain ShadowImplementation (we might not have to abstract this, could just use CSM(see below) ALL the time)\
	-Will be responsible for combining the lighting buffer(see below), the albedo buffer, and the shadow maps\
	-Will contain list of active PPS and set up that list based on configuration\
	-
\f0\b0 Will access and control the render list
\f1\b  and trigger the culling methods\

\f0\b0 	-Basically the god class
\f1\b \
\
Debug Rendering\
	-Debug transforms\
	-Debug Bounding Boxes\
	-Wireframe rendering\
\
Frustum Culling in Renderer Interface\
	
\f0\b0 -Frustum utility class
\f1\b \
	-Octree for a rough outline of visible entities\
	-Brute force the resulting octree list\
	-RenderObjects should add themselves to an \'93UpdatedObject\'94 list of the Renderer, re-position them in the octree and reset that list every frame\
	-Objects overlapping an octree node boundaries will have to be added to the parent node, which will include them more often in the final list, optimize this?\
\
After this the real fun starts\
Start Forward+ Implementation (Should probably rename Render Implementation to Lighting Implementation, since that\'92s the only thing we really want to abstract here?)\
	-Light collection and shader uniform passing\
	-actual shader lighting \'93modules\'94.\
	-Perhaps lighting implementations should just populate a \'93lighting buffer\'94 for use later outside of any specific implementation, rather than blend / create the final pre-pps image\
\
Basic Cascaded Shadow Maps (or other) implementation\
	-We can possibly decouple this from the lighting as well if lighting implementations output a seperate lighting buffer rather than make the final(pre-pps) image(see above)\
	-Combine this, the lighting buffer, and albedo when these maps are finally done \
\
Post Processing Stage(anything run after the lighting that uses the resulting rendered buffers)\
	-Be able to tell a Render implementation what buffers we want populated for various PPS effects (SSAO needs depth, HDR needs the lighting information, etc)\
	-SSAO\
	-HDR\
	-AA as a PPS?\
	-Custom, they can probably tell a shader module(see above) that a resulting value should populate a buffer(that they setup) when enabled\
	-Make it easy to override any default PPS with a new implementation (this is why decoupling it is so nice)\
\
Particle System\
	-GPU calculated\
	-Use modules to inject into shaders without caring what lighting implementation is used (this is the reason for decoupling the lighting and other shader code)\
\
Physically based rendering in our Forward+ Render(Lighting) implementation\
	-Fancy specular!\
	-All the material values should already be automatically passed (see above)\
\
Skinned animation\
	-Automatically passed uniforms and attributes if the mesh has them\
	-Vertex shader module (so it doesn\'92t matter what lighting implementation is used, it is decoupled)\
	-Must be very efficient, 30-40 skinned meshes with no impact?\
	-Add some debug rendering to show a bone skeleton, and potential toggle vertex weights for a single mesh at a time\
\
Potential Global Illumination implementations\
	-Does it go in the lighting implementations, or act similar to a pps?\
	-What is the most efficient implementation vs the best looking one\
\
(Optimizations along the way are next)\
	\
Occlusion Culling\
	-How does this not cause a problem with shadow mapping?\
\
Indoor Portal culling\
	-Might not be necessary\
}