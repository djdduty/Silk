Effect "FinalLightPass"
{
    Shader
    {
        //Remove this module once there are light volumes
        VertexModule "SetGLPosition" 0
        {
            gl_Position = vec4(a_Position,1.0);
        }
        VertexModule "SetTexCoords" 1
        {
            o_TexCoord = a_TexCoord;
        }
        FragmentFunction 0
        {
            vec4 sampleColor(vec2 texCoord)
            {
                vec4 Diffuse  = texture(u_FragColor     ,texCoord);
                vec4 Lighting = texture(u_FragLightAccum,texCoord);
                return Diffuse * Lighting;
            }

            vec4 FXAA()
            {
                vec2 InverseRes = vec2(1.0 / u_Resolution.x,1.0 / u_Resolution.y);

                vec3  luma   = vec3(0.299, 0.587, 0.114);
                float lumaTL = dot(sampleColor(o_TexCoord + (vec2(-1,-1) * InverseRes)).xyz, luma);
                float lumaTR = dot(sampleColor(o_TexCoord + (vec2( 1,-1) * InverseRes)).xyz, luma);
                float lumaBL = dot(sampleColor(o_TexCoord + (vec2(-1, 1) * InverseRes)).xyz, luma);
                float lumaBR = dot(sampleColor(o_TexCoord + (vec2( 1, 1) * InverseRes)).xyz, luma);
                float lumaM  = dot(sampleColor(o_TexCoord).xyz,  luma);

                vec2 dir;
                dir.x = -((lumaTL + lumaTR) - (lumaBL + lumaBR));
                dir.y = ((lumaTL + lumaBR) - (lumaTR + lumaBR));

                float dirReduce = max((lumaTL + lumaTR + lumaBL + lumaBR) * (ReduceMul * 0.25), ReduceMin);
                float inverseDirAdjustment = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);

                dir = min(vec2(MaxRadius, MaxRadius),
                    max(vec2(-MaxRadius, -MaxRadius), dir * inverseDirAdjustment)) * InverseRes.xy;

                vec3 result1 = (1.0/2.0) * (
                    sampleColor(o_TexCoord.xy + (dir * vec2(1.0/3.0 - 0.5))).xyz +
                    sampleColor(o_TexCoord.xy + (dir * vec2(2.0/3.0 - 0.5))).xyz);

                vec3 result2 = result1 * (1.0/2.0) + (1.0/4.0) * (
                    sampleColor(o_TexCoord.xy + (dir * vec2(0.0/3.0 - 0.5))).xyz +
                    sampleColor(o_TexCoord.xy + (dir * vec2(3.0/3.0 - 0.5))).xyz);

                float lumaMin = min(lumaM, min(min(lumaTL, lumaTR), min(lumaBL, lumaBR)));
                float lumaMax = max(lumaM, max(max(lumaTL, lumaTR), max(lumaBL, lumaBR)));
                float lumaResult2 = dot(luma, result2);

                if(lumaResult2 < lumaMin || lumaResult2 > lumaMax)
                    return vec4(result1, 1.0);
                else
                    return vec4(result2, 1.0);
            }
        }
        FragmentModule "SetColor" 0
        {
            vec4 sColor = FXAA();
        }
        Uniforms "Params"
        {
            float ReduceMin  = 1.0 / 128.0
            float ReduceMul  = 1.0 / 8.0
            float MaxRadius  = 8.0
        }
        Requires
        {
            //Uniforms
            Params
            ObjectData
            RenderData

            //Attributes
            a_Position
            a_TexCoord
        }
        VertexOutputs
        {
            a_TexCoord
        }
        TextureMaps
        {
            u_FragColor
            u_FragLightAccum
        }
        Outputs
        {
            f_Color
        }
    }
}
